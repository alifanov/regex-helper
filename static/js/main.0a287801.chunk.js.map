{"version":3,"sources":["RegexGenerator.js","App.js","serviceWorker.js","index.js"],"names":["deduplicateTokens","tokens","Set","exportTokens","pattern","text","match","exec","push","wordPattern","numberPattern","datePattern","hashPattern","ipPattern","ipv6Pattern","emailPattern","macAddressPattern","urlPattern","phoneNumberPattern","uuidPattern","patternExtractor","patternString","extractedTokens","RegExp","_","isEqual","guessNumberAlphaPattern","allTextParts","filter","p","part","includes","partInTokens","numberOfDigitsInTokens","map","t","length","minNumberInTokens","min","maxNumberInTokens","max","numberOfAlphaInTokens","minAlphaInTokens","maxAlphaInTokens","numberPatternPart","alphaNumberPart","candidates","negPart","negPattern","App","props","tokenPattern","initialText","_getTokens","state","_getPattern","patternCopied","contentEditable","React","createRef","_handleChange","bind","result","this","replace","token","naivePattern","join","textWithoutMarkup","patternCandidateExtractor","generateRegexPattern","tp","e","target","value","setState","className","href","rows","onChange","dangerouslySetInnerHTML","__html","_getHighlightedTokensText","toString","onCopy","setTimeout","icon","faCopy","style","color","Component","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.0a287801.chunk.js","sourcesContent":["import _ from 'lodash';\n\nexport const deduplicateTokens = tokens => [...new Set(tokens)];\n\nexport const exportTokens = (pattern, text) => {\n  const tokens = [];\n  let match = pattern.exec(text);\n\n  while (match && match[1]) {\n    tokens.push(match[1]);\n    match = pattern.exec(text);\n  }\n\n  return tokens;\n};\n\nconst wordPattern = /([a-zA-Z]+)/mg;\nconst numberPattern = /(\\d+)/mg;\nconst datePattern = /(\\d{1,2}[.-]\\d{1,2}[.-]\\d{2,4})/mg;\nconst hashPattern = /(\\d+[a-zA-Z]+\\w*|[a-zA-Z]+\\d+\\w*)/mg;\nconst ipPattern = /((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3})/mg;\nconst ipv6Pattern = /(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))/mg;\nconst emailPattern = /([^@ \\t\\r\\n]+@[^@ \\t\\r\\n]+\\.[^@ \\t\\r\\n]+)/mg;\nconst macAddressPattern = /[a-fA-F0-9]{2}(:[a-fA-F0-9]{2}){5}/mg;\nconst urlPattern = /https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/mg;\nconst phoneNumberPattern = /[+]?[(]?[0-9]{3}[)]?[-\\s.]?[0-9]{3}[-\\s.]?[0-9]{4,6}/mg;\nconst uuidPattern = /[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}/mg;\n\nconst patternExtractor = patternString => (tokens, text) => {\n  const extractedTokens = deduplicateTokens(exportTokens(new RegExp(patternString), text));\n  if (_.isEqual(tokens, extractedTokens)) {\n    return new RegExp(patternString);\n  }\n};\n\nconst partInTokens = (part, tokens) => {\n  for (const token of tokens) {\n    if (token.includes(part)) {\n      return true;\n    }\n  }\n  return false;\n};\n\nexport const guessNumberAlphaPattern = (tokens, text) => {\n  let allTextParts = exportTokens(/([a-zA-Z]+)/g, text);\n  allTextParts = allTextParts.filter(p => !partInTokens(p, tokens));\n\n  const numberOfDigitsInTokens = tokens.map(t => (exportTokens(/(\\d+)/g, t)[0] || '').length);\n  const minNumberInTokens = _.min(numberOfDigitsInTokens);\n  const maxNumberInTokens = _.max(numberOfDigitsInTokens);\n\n  const numberOfAlphaInTokens = tokens.map(t => (exportTokens(/([a-zA-Z]+)/g, t)[0] || []).length);\n  const minAlphaInTokens = _.min(numberOfAlphaInTokens);\n  const maxAlphaInTokens = _.max(numberOfAlphaInTokens);\n\n  const numberPatternPart = minNumberInTokens !== maxNumberInTokens ? `\\\\d{${minNumberInTokens},${maxNumberInTokens}}` : `\\\\d{${minNumberInTokens}}`;\n  const alphaNumberPart = minAlphaInTokens !== maxAlphaInTokens ? `[a-zA-Z]{${minAlphaInTokens},${maxAlphaInTokens}}` : `[a-zA-Z]{${minAlphaInTokens}}`;\n\n  const candidates = [\n    `${numberPatternPart}${alphaNumberPart}`,\n    `${alphaNumberPart}${numberPatternPart}`,\n\n    `${numberPatternPart}${alphaNumberPart}${numberPatternPart}`,\n    `${alphaNumberPart}${numberPatternPart}${alphaNumberPart}`,\n\n    `${numberPatternPart}${alphaNumberPart}${numberPatternPart}${alphaNumberPart}`,\n    `${alphaNumberPart}${numberPatternPart}${alphaNumberPart}${numberPatternPart}`,\n  ];\n\n  for (const patternString of candidates) {\n    const extractedTokens = deduplicateTokens(exportTokens(new RegExp(`(${patternString})`, 'g'), text));\n    if (_.isEqual(tokens, extractedTokens)) {\n      return new RegExp(`(${patternString})`, 'g');\n    }\n  }\n\n  for (const patternString of candidates) {\n    for (const negPart of allTextParts) {\n      const negPattern = `((?!${negPart})${patternString})`;\n      const extractedTokens = deduplicateTokens(exportTokens(new RegExp(negPattern, 'g'), text));\n      if (_.isEqual(tokens, extractedTokens)) {\n        return new RegExp(negPattern, 'g');\n      }\n    }\n  }\n\n  for (const negPart of allTextParts) {\n    for (const patternString of [\n      `(${numberPatternPart}(?!${negPart})${alphaNumberPart})`,\n      `(${alphaNumberPart}(?!${negPart})${numberPatternPart})`,\n\n      `(${numberPatternPart}${alphaNumberPart}(?!${negPart})${numberPatternPart})`,\n      `(${alphaNumberPart}${numberPatternPart}(?!${negPart})${alphaNumberPart})`,\n\n      `(${numberPatternPart}${alphaNumberPart}${numberPatternPart}(?!${negPart})${alphaNumberPart})`,\n      `(${alphaNumberPart}${numberPatternPart}${alphaNumberPart}(?!${negPart})${numberPatternPart})`,\n    ]) {\n      const extractedTokens = deduplicateTokens(exportTokens(new RegExp(patternString, 'g'), text));\n      if (_.isEqual(tokens, extractedTokens)) {\n        return new RegExp(patternString, 'g');\n      }\n    }\n  }\n};\n\nexport default function generateRegexPattern(tokens, text) {\n  const naivePattern = new RegExp(tokens.length > 1 ? `(${tokens.join('|')})` : tokens, 'g');\n\n  const textWithoutMarkup = text.replace(/{/g, '').replace(/}/g, '');\n\n  const patternCandidates = [\n    patternExtractor(ipPattern),\n    patternExtractor(ipv6Pattern),\n    patternExtractor(phoneNumberPattern),\n    patternExtractor(numberPattern),\n    patternExtractor(emailPattern),\n    patternExtractor(datePattern),\n    patternExtractor(wordPattern),\n    patternExtractor(macAddressPattern),\n    patternExtractor(urlPattern),\n    patternExtractor(uuidPattern),\n    guessNumberAlphaPattern,\n    patternExtractor(hashPattern),\n  ];\n\n  for (const patternCandidateExtractor of patternCandidates) {\n    const pattern = patternCandidateExtractor(tokens, textWithoutMarkup);\n    if (pattern) {\n      return pattern;\n    }\n  }\n\n  return naivePattern;\n};","import React from 'react';\nimport {CopyToClipboard} from 'react-copy-to-clipboard';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome'\nimport { faCopy } from '@fortawesome/free-regular-svg-icons'\n\n\nimport './App.css';\n\n\nimport generateRegexPattern, {exportTokens, deduplicateTokens} from \"./RegexGenerator\";\n\nconst Checkbox = ({key, label, handleChange}) => {\n  return (<label>\n    <input type=\"checkbox\" onChange={handleChange}/>\n    {label}\n  </label>)\n};\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.tokenPattern = /{([^}]*)}/g;\n\n    const initialText = 'my postcode is {BC123DO}\\nthis is your postcode {aa321sd}\\nthis is wrong postcode aa132ee';\n    const tokens = this._getTokens(initialText);\n\n    this.state = {\n      initialText,\n      text: initialText,\n      pattern: this._getPattern(tokens, initialText),\n      patternCopied: false,\n      tokens: tokens,\n    };\n    this.contentEditable = React.createRef();\n    this._handleChange = this._handleChange.bind(this);\n\n  }\n\n  _getHighlightedTokensText() {\n    let result = this.state.text.replace(/{/g, '').replace(/}/g, '');\n    for (const token of this.state.tokens) {\n      result = result.replace(token, `<span class=\"badge badge-success\">${token}</span>`)\n    }\n    return result.replace(/\\n/g, '<br/>');\n  }\n\n  _getTokens(text) {\n    return deduplicateTokens(exportTokens(this.tokenPattern, text));\n  }\n\n  _getPattern(tokens, text) {\n    return generateRegexPattern(tokens.map(tp => tp.replace(/{/g, '').replace(/}/g, '')), text);\n  }\n\n  _handleChange(e) {\n    const text = e.target.value;\n    this.setState({text});\n    let tokens = this._getTokens(text);\n    // const lines = text.split(/\\r?\\n/).filter(v => !!v);\n    if (tokens.length > 0) {\n      this.setState({tokens});\n      const pattern = this._getPattern(tokens, text);\n      if (pattern) {\n        this.setState({pattern});\n      }\n    }\n  }\n\n  render() {\n    return (\n      <div>\n        <nav className=\"navbar navbar-expand-lg navbar-light bg-light justify-content-center\">\n          <a className=\"navbar-brand\" href=\"/\">Regex Helper</a>\n        </nav>\n        <div className='container'>\n          <div className='block'>\n            Use <code>{'{'}{'}'}</code> brackets to wrap tokens you want to extract from text\n          </div>\n          <div className=\"block\">\n            <textarea className='textArea form-control' rows={5} onChange={this._handleChange}>{this.state.initialText}</textarea>\n          </div>\n          <div className=\"jumbotron\">\n            <div className='output' dangerouslySetInnerHTML={{__html: this._getHighlightedTokensText()}}/>\n          </div>\n          {this.state.pattern && (<div>\n            <p>Seems your pattern is: <code>{this.state.pattern.toString()}</code> <CopyToClipboard text={this.state.pattern}\n                                                                                                    onCopy={() => {\n                                                                                                      this.setState({patternCopied: true});\n                                                                                                      setTimeout(() => this.setState({patternCopied: false}), 1000)\n                                                                                                    }}>\n              <FontAwesomeIcon icon={faCopy} />\n            </CopyToClipboard>         {this.state.patternCopied ? <span style={{color: 'grey'}}>Copied</span> : null}\n            </p>\n            {/*{this.state.tokens.map((t, i) => <div>{t}: {[\"number\", \"text\", \"date\"].map(_type => <Checkbox key={i}*/}\n            {/*                                                                                              label={_type}/>)}</div>)}*/}\n          </div>)}\n          <div className=\"complain-guide text-center\">\n            <p>Please, don't hesitate to create <a href=\"https://github.com/alifanov/regex-helper/issues\">issues on Github</a></p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport 'bootswatch/dist/flatly/bootstrap.min.css';\nimport './index.css';\n\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}